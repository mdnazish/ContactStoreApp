package com.mn.contactstore.dao;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import com.mn.contactstore.domain.User;
import com.mn.contactstore.rowmapper.UserRowMapper;

/**
 * @author Md Nazish
 *
 */
@Repository("userDao")
public class UserDaoImpl extends AbstractBaseDao implements UserDao {

	@Override
	public boolean addUser(User user) {
		String sqlQuery = "INSERT INTO user(name, phone, email, address, login_name, password, role, login_status)"
				+ " VALUES(:name, :phone, :email, :address, :loginName, :password, :role, :loginStatus)";
		if (user != null) {
			// Bind the value for these named parameter
			Map map = new HashMap();
			map.put("name", user.getName());
			map.put("phone", user.getPhone());
			map.put("email", user.getEmail());
			map.put("address", user.getAddress());
			map.put("loginName", user.getLoginName());
			map.put("password", user.getPassword());
			map.put("role", user.getRole());
			map.put("loginStatus", user.getLoginStatus());

			// now bind the values which auto-incremented and generated by the DB
			KeyHolder keyHolder = new GeneratedKeyHolder();

			// from where, all values for the named parameter is supplied
			SqlParameterSource paramValue = new MapSqlParameterSource(map);

			// execute the query with named parameters and keyHolder
			super.getNamedParameterJdbcTemplate().update(sqlQuery, paramValue, keyHolder);

			// get userId from KeyHolder and set to the User
			Integer userId = keyHolder.getKey().intValue();
			user.setUserId(userId);

			return true;
		} else {
			return false;
		}
	}

	@Override
	public User getUserById(Integer userId) {

		String sqlQuery = "SELECT user_id, name, phone, email, address, login_name, role, login_status"
				+ " FROM user WHERE user_id=?";

		// Use queryForObject(-,-,-) method tO fetch single record from DB
		User user = getJdbcTemplate().queryForObject(sqlQuery, new UserRowMapper(), userId);

		return user;
	}

	@Override
	public boolean updateUser(User user) {
		String sqlQuery = "UPDATE user " + " SET name=:name," + " phone=:phone, " + " email=:email,"
				+ " address=:address," + " role=:role," + " login_status=:loginStatus " + " WHERE user_id=:userId";

		if (user != null) {
			Map map = new HashMap();
			map.put("name", user.getName());
			map.put("phone", user.getPhone());
			map.put("email", user.getEmail());
			map.put("address", user.getAddress());
			map.put("role", user.getRole());
			map.put("loginStatus", user.getLoginStatus());
			map.put("userId", user.getUserId());

			getNamedParameterJdbcTemplate().update(sqlQuery, map);
			return true;
		} else {

			return false;
		}
	}

	@Override
	public boolean deleteUser(User user) {
		if (user != null) {
			this.deleteUserById(user.getUserId());
			return true;
		} else {
			return false;
		}
	}

	@Override
	public boolean deleteUserById(Integer userId) {
		String sqlQuery = "DELETE FROM user WHERE user_id=?";
		getJdbcTemplate().update(sqlQuery, userId);
		return true;
	}

	@Override
	public List<User> findAll() {
		String sqlQuery = "SELECT user_id, name, phone, email, address, login_name, role, login_status"
				+ " FROM user";
		
		// Use query(-,-) method to fetch all record from DB
		return getJdbcTemplate().query(sqlQuery, new UserRowMapper());
	}

	@Override
	public List<User> findByProperty(String propName, Object propValue) {
		String sqlQuery = "SELECT user_id, name, phone, email, address, login_name, role, login_status"
				+ " FROM user WHERE " + propName + "=?";
		
		return getJdbcTemplate().query(sqlQuery, new UserRowMapper(), propValue);
	}

}
